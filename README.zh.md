# Python命令工具

## 要求
+ python3.5 +

## 安装
```
1. pip install bdpycmd
2. pip install -i https://pypi.org/simple/ bdpycmd==real_version
```

## 描述
```
它用于作为命令行运行Python代码。 
它只适用于类方法。 
在类方法上添加as_cmder decorator，并在命令文件目录中创建命令类。 
在项目根目录中，创建一个pycmd.py文件，并导入bdpycmd.pycmd模块下的所有内容。 
将初始化代码和执行条目添加到pycmd.py中。 
打开命令行界面，转到项目根目录（与pycmd.py文件的级别相同），然后运行python pycmd.py。
```

## 使用方式
```
# 你的python项目目录 
home/app/your_python_project
# 在你的python项目目录下创建一个pycmd.py文件，作为交互式命令执行的入口
home/app/your_python_project/pycmd.py
# 在你的python项目目录下创建一个cmder目录，用于存储生产的可执行命令
home/app/your_python_project/cmder
# 假设你的python项目目录下有一个tasks目录，在该目录里你开发你的python脚本
home/app/your_python_project/tasks/

1，那么你的 pycmd.py文件中应该如下
from bdpycmd.pycmd import *

CmdBaseConf.init(
    root_dir=".",
    cmd_dir='cmder'
)

if __name__ == "__main__":
    CmdBaseConf.run()

2，假设你在tasks目录下有一个脚本,demo.py，那么如果让这个脚本能够以命令行交互形式运行，你的内容大致如下
from bdpycmd.cmd.factory.base import BaseCommand as bscm

class SayHi:
    """
    打招呼
    """

    # 以装饰器的形式注入到命令行
    @bscmd.as_cmder
    def say(self,name:str):
        """
        打招呼

        :param name: str 来人姓名
        """
        print(f"Hi {name} I`m {__name__}")

3，你需要在项目主目录下运行助手命令来生成这个demo.py的可执行命令文件，具体交互内容大致如下
>> python ./pycmd.py
command line interpreter
        
        :param cmd:      parent command name  If this parameter is omitted, the help is called
        :param son:      subcommand name  If this parameter is omitted, help is called
        :param **kwargs: Subcommand arguments Unsupported arguments are filtered out
        

        >>> Selection Parent Command : Commands

        < assistant > . Command Info 
        Number: 0
        command base class
        Generate execution commands from existing modules   
        
>> / # 键入 ”/“ 表示选中命令

        >>> Running Parent Command : 
        < bdpycmd.cmd.camp.assistant >
        command assistant
        Generate execution commands from existing modules
        

        >>> Select Son Method : Methods 

        [ make_cmd ] of Command . Method Info 
        Number: 0
        Create a command from a module
            
            :param mpth:  str #Module relative path, such as: a/b/c
            :param cls:   str #Class name
            :param cdir:  str #Relative Directory, such as: ./cmder
            :param cmd:   str #Command name
            :param alias: str #command alias
            :param desc:  str #command description
            :param abs:   str #Do you want to forcibly replace existing command files. yes/no
              
        
>> / # 键入 ”/“ 表示选中命令的可执行方法

        >>> Running Son Method : 
        [ make_cmd ] of Command
        Create a command from a module
            
            :param mpth:  str #Module relative path, such as: a/b/c
            :param cls:   str #Class name
            :param cdir:  str #Relative Directory, such as: ./cmder
            :param cmd:   str #Command name
            :param alias: str #command alias
            :param desc:  str #command description
            :param abs:   str #Do you want to forcibly replace existing command files. yes/no
            
        
>> mpth = tasks/demo
>> cls = SayHi
>> cdir = ./cmder
>> cmd = say_hai
>> alias = 打招呼       
>> desc = 打招呼
>> abs = yes    

     Command created successfully

此时助手命令会在 ./cmder 目录下面生产一个 say_hi.py文件，这就是命令行交互时真正执行的文件，这个文件的内容如下，另外请不要编辑这个文件
# This file is a command execution file generated by the command assistant. 
# Do not edit it.

from bdpyconsts import bdpyconsts as pyconst

# Command Description Information
_BDCMD_DESC_ = {
    "name":'say_hai',
    "alias":'打招呼',
    "desc":'打招呼'
}

if pyconst._BD_CMD_RUN_NOW == True:
    from bdpycmd.cmd.factory.base import BaseCommand 
    from tasks.demo import SayHi

    class Command(BaseCommand,SayHi):
        def __init__(self):
            super().__init__(name=__class__.__module__,alias='打招呼',description='打招呼')
            super(BaseCommand,self).__init__()

4，现在假设你的这个脚本在线上服务中执行失败了，你需要在本地运行来弥补错误，此时你就可以通过命令行进入到项目主目录下并执行这个命令，特别是命令方法的参数需要动态调整时这种交互式的执行方式比较方便，又或者你需手动更改参数来调整脚本性能的时候，执行方式如下
>> python ./pycmd.py 
command line interpreter
        
        :param cmd:      parent command name  If this parameter is omitted, the help is called
        :param son:      subcommand name  If this parameter is omitted, help is called
        :param **kwargs: Subcommand arguments Unsupported arguments are filtered out
        

        >>> Selection Parent Command : Commands

        < assistant > . Command Info 
        Number: 0
        command base class
        Generate execution commands from existing modules   
        
>> say # 键入具体内容，表示查找命令

        < say_hai > . Command Info 
        Number: 9
        打招呼
        打招呼   
        
>> / # 键入 ”/“ 表示选中命令

        >>> Running Parent Command : 
        < cmder.say_hai >
        打招呼
        打招呼
        

        >>> Select Son Method : Methods 

        [ say ] of SayHi . Method Info 
        Number: 0
        打招呼

        :param name: str 来人姓名
          
        
>> sa # 键入具体内容，表示查找命令的可执行方法

        [ say ] of SayHi . Method Info 
        Number: 0
        打招呼

        :param name: str 来人姓名
          
        
>> / # 键入 ”/“ 表示选中命令的可执行方法

        >>> Running Son Method : 
        [ say ] of SayHi
        打招呼

        :param name: str 来人姓名
        
        
>> name = 约翰
Hi 约翰 I`m unit.demo.say_hi

5，在命令交互时有以下几个特殊符号
输入 “.” 之后 按下回车键，表示退出命令交互 
输入 “/” 之后 按下回车键，表示选中当前命令或者命令的方法
输入 其他内容 之后 按下回车键，表示搜索命令或者命令的方法
在命令或者方法选中之前，不输入任何内容直接按下回车键表示显示下一个命令或方法
```

## 使用示例项目url
<https://github.com/biandoucheng/open-example/tree/main/bdpycmd-example>

## 源代码url
<https://github.com/biandoucheng/bd-py-cmd>

## 注释规范
```
在命令方法中添加注释时，必须遵守以下规则，否则将无法正确解析命令参数

@base.BaseCommand.as_cmder
def your_func(p1,p2):
    """
    您的函数描述

    :param p1: type #描述
    :param p2: type #描述
    :return: type
    """
    your_func_content ...
```

## 更新日志
```
2023.06.13
1. 支持命令关键字检索:
    没有内容输入，直接按Enter键即可执行下一个命令 
    输入命令编号或任意内容，将根据提供的内容查询相关命令 
    输入“/”符号以退出帮助提示

2. 支持在命令查询期间直接查询命令的可执行方法
    输入“.” 立即退出帮助提示 
    输入“/” 以查询所选命令的可执行方法

3. 修复Bug
    修复运行字典中“None”参数导致的执行错误问题，并优化信息输出

2023.06.14
1. 查询命令可执行方法时支持直接执行方法
    输入“.” 立即退出帮助提示 
    输入“/” 以执行所选命令的所选方法
2. 修复Bug
    修复命令方法帮助中的“m”参数错误
3. 修复Bug
    修复命令生成助手生成命令错误的问题
4. 优化
    优化命令生成助手，使命令生成方法的参数更清晰、更易于使用
5. 优化
    使用命令助手生成命令时，支持强制覆盖现有命令文件的参数“abs”

2023.06.15
1. 修复Bug
    修复关键字检索方法中的错误

2023.06.20
1. 优化助手命令
    优化命令文件名的命名。允许参数cmd作为命令和命令文件的名称传入。

2023.07.06
1. 优化命令列表
    优化的命令识别速度。根据是否需要执行命令方法动态确定是否导入命令实现类，以显著减少列出命令时需要加载的模块数量，从而加快命令列表的显示

2023.07.10
1. 修复命令模块导入错误
    修复命令执行错误 `run command failed: module 'cmder.***' has no attribute 'Command' ` 这是由于延迟加载命令实现模块造成的。

2023.12.07
1.修复只有一个命令或方法时回车导致直接选择命令或方法执行的错误。

2023.12.19
1. 修复了标记为命令的函数无法通过参数输入不完整的函数调用直接执行的问题

2024.01.11
1. 修复Bug
    修复了在基于输入内容搜索命令或方法时，如果搜索为空，则会导致无限循环的问题。
2. 优化帮助信息显示
    使命令查找或者方法查找时，命名和方法被显示的更清楚，命令被 <命令> 包裹，方法被 [方法] 包裹
```